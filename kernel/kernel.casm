; CrypticOS Kernel / Internal standard function library
; k.get, k.add, k.mult, k.div, k.higher

; General purpose variables
; (general a, b, c, d)
var gc 0 ; General c
var gb 0 ; General b
var ga 0 ; General a
var gr 0 ; General result
var gd 0 ; General d

jmp k.end ; jmp program start

; ga = operation
; gb = location
; gc = value to set/get
k.get:
	inl "d<<<^" ; Reserve for operation
	inl "d<^" ; reserve for location
	inl "d<^>>>>>d" ; Reserve for value to set or value to get
	inl "d" ; reserve for temp
	inl "d" ; reserve for label, set in loop (label)
	inl "!^d" ; store zero to compare (value1)
	inl "aaaaavddddd^" ; store value from fourth cell (value2)
	inl "aa" ; go back
	k.get_back:
		inl "a^d" ; store current cell temp
		inl "!+++^"; Go to label 3 (k.get_back.end)
		inl "avd" ; restore temp value
		inl "<"

		; to go matching register + 1, store temp,
		; sub matching register, return back
		inl "ddd^"
		inl "av-^dvaaa"
	inl "?" ; equ

	; Goto
	inl "a^d" ; store current cell temp
	inl "!++^"; Go to label 2 (k.get_back)
	inl "avd" ; restore temp value
	inl "$"

	k.get_back_end:
	; Store value.

	inl "a^" ; store temp
	inl "d!*-^" ; store label 4 (k.get_set)
	inl "d!+^" ; store 1
	inl "aaaaavdddddd^" ; store operation reg
	inl "aa" ; back to label
	inl "avd" ; restore value
	inl "?"

	; If operation is not 1 (2)
	inl "aavdd" ; set value
	k.get_set:
	; If operation is 1:
	inl "aa^dd" ; put char into value

	; Now we are currently in the label reg.
	; Go back to temp reg and store current memory cell.
	inl "a^d"

	inl "d" ; space for label
	inl "!^d" ; store zero to compare
	inl "aaaaavddddd^" ; store 4 to compare (matching register)
	inl "aa" ; go back
	inl "avd" ; Restore temp value
	k.get_forward:
		inl "a^d" ; store current cell temp
		inl "!*+^"; Go to label 5 (k.get_forward.back)
		inl "avd" ; restore temp value
		inl ">"

		; to go matching register + 1, store temp,
		; sub matching register, return back
		inl "ddd^"
		inl "av-^dvaaa"
	inl "?" ; equ

	; Goto
	inl "a^d" ; store current cell temp
	inl "!*^"; Go to label 4 (k.get_forward)
	inl "avd" ; restore temp value
	inl "$"
	k.get_forward_back:
	inl "aa<<v>>aaa" ; go to initial value, when started
ret

; Add ga until gb is zero
k.add:
	cmp gb 0 k.add_stop ; is d zero? then stop
	add ga 1 ; increase first and
	sub gb 1 ; decrease second
	jmp k.add
	k.add_stop:
	mov gr ga
ret

; divmod algorithm
k.divide:
	add gr 1
	mov gd gb
	k.divide_sub:
		cmp gd 0 k.divide
		sub gd 1
		cmp ga 0 k.divide_exit
		sub ga 1
	jmp k.divide_sub
	k.divide_exit:

	; Do offsets from 
	sub gr 1
	add gd 1
ret

k.mult:
	mov gr 0
	cmp gb 0 k.mult_end
	mov gd ga
	k.mult_add:
		cmp gd 0 k.mult_add_end
		add gr 1
		sub gd 1
		jmp k.mult_add
	k.mult_add_end:
	sub gb 1
	jmp k.mult
	k.mult_end:
ret

k.higher:
	cmp gb 0 k.higher_secondHigher
	cmp ga 0 k.higher_firstHigher
	sub ga 1
	sub gb 1
	jmp k.higher

	k.higher_firstHigher:
		mov gr, 2
	ret

	k.higher_secondHigher:
	mov gr 1
ret

k.end:

; 3 * 2 from kernel, print 6
; mov ga 3
; mov gb 2
; call k.mult
; add gr '0'
; out gr
