; CrypticOS Kernel

def GET 2
def SET 1

; General purpose variables
; (general a, b, c, d)
var gc 0 ; General c
var gb 0 ; General b
var ga 0 ; General a
var gr 0 ; General result
var gd 0 ; General d

jmp k.end ; jmp program start

; ga = operation
; gb = location
; gc = value to set/get
k.get:
	inl "d<<<^" ; Reserve for operation
	inl "d<^" ; reserve for location
	inl "d<^>>>>>d" ; Reserve for value to set or value to get
	inl "d" ; reserve for temp
	inl "d" ; reserve for label, set in loop (label)
	inl "!^d" ; store zero to compare (value1)
	inl "aaaaavddddd^" ; store value from fourth cell (value2)
	inl "aa" ; go back
	k.get_back:
		inl "a^d" ; store current cell temp
		inl "!+++^"; Go to label 3 (k.get_back.end)
		inl "avd" ; restore temp value
		inl "<"

		; to go matching register + 1, store temp,
		; sub matching register, return back
		inl "ddd^"
		inl "av-^dvaaa"
	inl "?" ; equ

	; Goto
	inl "a^d" ; store current cell temp
	inl "!++^"; Go to label 2 (k.get_back)
	inl "avd" ; restore temp value
	inl "$"

	k.get_back_end:
	; Store value.

	inl "a^" ; store temp
	inl "d!*-^" ; store label 4 (k.get_set)
	inl "d!+^" ; store 1
	inl "aaaaavdddddd^" ; store operation reg
	inl "aa" ; back to label
	inl "avd" ; restore value
	inl "?"

	; If operation is not 1 (2)
	inl "aavdd" ; set value
	k.get_set:
	; If operation is 1:
	inl "aa^dd" ; put char into value

	; Now we are currently in the label reg.
	; Go back to temp reg and store current memory cell.
	inl "a^d"

	inl "d" ; space for label
	inl "!^d" ; store zero to compare
	inl "aaaaavddddd^" ; store 4 to compare (matching register)
	inl "aa" ; go back
	inl "avd" ; Restore temp value
	k.get_forward:
		inl "a^d" ; store current cell temp
		inl "!*+^"; Go to label 5 (k.get_forward.back)
		inl "avd" ; restore temp value
		inl ">"

		; to go matching register + 1, store temp,
		; sub matching register, return back
		inl "ddd^"
		inl "av-^dvaaa"
	inl "?" ; equ

	; Goto
	inl "a^d" ; store current cell temp
	inl "!*^"; Go to label 4 (k.get_forward)
	inl "avd" ; restore temp value
	inl "$"
	k.get_forward_back:
	inl "aa<<v>>aaa" ; go to initial value, when started
ret

k.reset:
	set gc 0
	set gb 0
	set ga 0
	set gr 0
	set gd 0
ret

; Simply Add ga until gb is zero
k.add:
	equ gb 0 k.add_stop ; is d zero? then stop
	add ga 1 ; increase first and
	sub gb 1 ; decrease second
	jmp k.add
	k.add_stop:
	set gr ga
ret

; divmod algorithm
k.div:
	add gr 1
	set gd 0
	k.div_sub:
		equ gd gb k.div
		add gd 1
		equ ga 0 k.div_exit
		sub ga 1
	jmp k.div_sub
	k.div_exit:

	; Do offsets from 
	sub gr 1
	sub gd 1
ret

; gr = result
; gd = remainder
k.mult:
	set gr 0 ; reset result, will add
	k.mult_top:
	equ gb 0 k.mult_end
	set gd ga
	
	k.mult_add:
		equ gd 0 k.mult_add_end
		add gr 1
		sub gd 1
	jmp k.mult_add

	k.mult_add_end:
	sub gb 1
	jmp k.mult_top
	k.mult_end:
ret

k.high:
	equ gb 0 k.high_secondHigher
	equ ga 0 k.high_firstHigher
	sub ga 1
	sub gb 1
	jmp k.high

	k.high_firstHigher:
		set gr 1
	ret

	k.high_secondHigher:
	set gr 0
ret

k.end:

;set gr 0
;set ga 22
;set gb 7
;run k.div
;add gd '0'
;prt gd

